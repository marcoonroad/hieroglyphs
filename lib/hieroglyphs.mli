(** Quantum-resistant, purely Hash-based, Stateful, One-Time Digital Signatures for OCaml.
    @author Marco AurÃ©lio da Silva
    @version 0.0.1
*)

(** Hieroglyphs is a hash-based signature scheme, which, in so far, is resistant to
    Quantum machine attacks (unlike RSA and Elliptic Curves, which can be broken).
    This "Quantum attack" is a mean to obtain the private key with just the public key, that
    is, this break the said hard/infeasible public key inversion theorem, as proved on
    classical machines.

    Alongside with the Hash-based Signatures, there are as well other proposed Digital Signature
    schemes which are resistant to Quantum attacks. Such cryptography is often known as
    {i Post-quantum Cryptography}. One of the most famous candidates for the "Quantum Apocalypse" is
    the Ring Learning With Errors Signature, an instance of the Lattice-based Cryptography
    (said to be resistant to Quantum key inversion attacks).
*)

(** The opaque/abstract type for our private keys. *)
type priv

(** The opaque/abstract type for our public keys. *)
type pub

val generate : unit -> priv
(** Generates an unique private key. *)

val derive : priv -> pub
(** Derives an unique public key from private key. *)

val pair : unit -> priv * pub
(** Helper function which generates a signature key pair. *)

val export : priv:priv -> pass:string -> string
(** [export ~priv ~pass] dumps an encrypted version of
    the private key. *)

val import : cipher:string -> pass:string -> priv option
(** [import ~cipher ~pass] tries to load a previously exported
    private key, only if the cipher text and the password yield
    a valid, internally parseable private key. *)

val load : string -> pub option
(** [load text] parses a valid public key, otherwise, returns None. *)

val show : pub -> string
(** [show pubkey] dumps/serialize a public key under string format. *)

val address : pub -> string
(** [address pubkey] generates an unique, deterministic ID for given
    public key. It's useful, for instance, to externally track the
    used/consumed private keys with a maintained state under a blacklist,
    cause there's an unique mapping from {i priv} to {i pub}, and therefore,
    from {i priv} to {i id : string} (the composition of [derive] with
    [address]. *)

val sign : priv:priv -> msg:string -> string option
(** [sign ~priv ~msg] creates a deterministic string signature
    given the same private key and same message. Fails if the private
    key was already used previously to sign a message, even if the
    message was the same (TODO: it's safe to sign many times the
    same message, 'cause it still makes inversion/prediction attacks
    impossible). *)

val verify : pub:pub -> msg:string -> signature:string -> bool
(** [verify ~pub ~msg ~signature] succeeds if the signature is valid
    for given message and was generated by the private key which
    generated the given public key. *)
